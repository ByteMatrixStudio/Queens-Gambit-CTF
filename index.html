<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Queens Gambit CTF</title>

  <!-- chessboard.js CSS -->
  <link rel="stylesheet"
        href="./assets/vendor/chessboardjs-1.0.0/css/chessboard-1.0.0.min.css">

  <style>
    /* Dark mode page + centered layout */
    body {
      margin: 0;
      min-height: 100vh;
      background: #0b0f14;
      color: #e6edf3;
      font-family: Arial, sans-serif;

      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;

      gap: 18px;
    }

    h1 {
      margin: 0;
      font-size: 48px;
      letter-spacing: 1px;
    }

    /* Bigger board */
    #board {
      width: 720px;      /* change to 800/900 if you want */
      max-width: 92vw;   /* responsive */
    }

    /* Card wrapper */
    .wrap {
      padding: 28px;
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.04);
      box-shadow: 0 10px 30px rgba(0,0,0,0.45);
      width: fit-content;
    }

    #status {
      margin-top: 14px;
      font-size: 18px;
      opacity: 0.95;
      max-width: 720px;
      line-height: 1.35;
    }

    /* Success / flag screen */
    #successScreen {
      display: none;
      padding: 28px;
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.04);
      box-shadow: 0 10px 30px rgba(0,0,0,0.45);
      width: min(900px, 92vw);
      text-align: center;
    }

    #successScreen h2 {
      margin: 0 0 10px 0;
      font-size: 42px;
      letter-spacing: 1px;
    }

    #successScreen p {
      margin: 0 0 18px 0;
      opacity: 0.9;
      font-size: 18px;
    }

    #flagImage {
      width: 100%;
      max-width: 820px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 12px 40px rgba(0,0,0,0.55);
    }

    #restartBtn {
      margin-top: 18px;
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color: #e6edf3;
      cursor: pointer;
      font-size: 16px;
    }
    #restartBtn:hover {
      background: rgba(255,255,255,0.10);
    }
  </style>
</head>

<body>

  <!-- Main game screen -->
  <div class="wrap" id="gameScreen">
    <h1>Chess Board</h1>

    <!-- The board renders inside this div -->
    <div id="board"></div>

    <!-- Hint/status output -->
    <div id="status"></div>
  </div>

  <!-- Success screen (shows an image with the flag) -->
  <div id="successScreen">
    <h2>Well played.</h2>
    <p>The position feels… familiar. Claim your reward.</p>

    <!-- Put your image here (recommended: store locally in repo) -->
    <!-- Example path: ./assets/flag.png -->
    <img id="flagImage" src="./assets/flag.png" alt="Flag">

    <div>
      <button id="restartBtn" type="button">Restart</button>
    </div>
  </div>

  <!-- ================== SCRIPTS (ORDER MATTERS) ================== -->

  <!-- 1) jQuery (required by chessboard.js) -->
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

  <!-- 2) chess.js (rules engine) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

  <!-- 3) chessboard.js (visual board + dragging) -->
  <script src="./assets/vendor/chessboardjs-1.0.0/js/chessboard-1.0.0.min.js"></script>

  <!-- 4) CTF logic -->
  <script>
    // =========================
    // CTF SETTINGS
    // =========================

    // Scripted solution path:
    // each step is White move (w) then Black reply (b)
    // Use UCI like "d2d4", "g1f3", etc.
    const SCRIPT = [
      { w: "d2d4", b: "d7d5" }, // 1. d4 d5
      { w: "c2c4", b: "e7e6" }, // 2. c4 e6 (QGD)
      { w: "b1c3", b: "g8f6" }, // 3. Nc3 Nf6
      // Add more steps here
    ];

    // Win condition: when a specific piece ends up on a specific square
    // piece values: wK,wQ,wR,wB,wN,wP and bK,bQ,bR,bB,bN,bP
    const WIN_CONDITION = { piece: "wQ", square: "e7" };

    // Hint text (vague, but nudges them). One per step is nice.
    const STEP_HINTS = [
      "The center matters. Control it early.",
      "A familiar pawn sacrifice tempts black…",
      "Develop with purpose. Don’t move the same piece twice without a reason.",
      "Keep going…"
    ];

    // More generic feedback
    const WRONG_MOVE_HINTS = [
      "Hmm… that doesn’t fit the idea.",
      "Feels off. Think about the center.",
      "Not quite. There’s a classic plan here.",
      "Close, but the position wants something more principled."
    ];

    // =========================
    // SETUP
    // =========================

    const gameScreen = document.getElementById("gameScreen");
    const successScreen = document.getElementById("successScreen");
    const restartBtn = document.getElementById("restartBtn");

    const statusEl = document.getElementById("status");

    function setStatus(msg) {
      statusEl.textContent = msg;
    }

    function showSuccessScreen() {
      gameScreen.style.display = "none";
      successScreen.style.display = "block";
    }

    function toUCI(from, to) {
      return from + to;
    }

    function makeMoveUCI(uci, promotion) {
      return game.move({
        from: uci.slice(0, 2),
        to: uci.slice(2, 4),
        promotion: promotion || "q"
      });
    }

    function isPieceOnSquare(pieceCode, square) {
      const sq = game.get(square); // {type:'p', color:'w'} or null
      if (!sq) return false;
      const actual = (sq.color + sq.type).toLowerCase(); // e.g. "wq"
      return actual === pieceCode.toLowerCase();
    }

    function checkWinCondition() {
      if (isPieceOnSquare(WIN_CONDITION.piece, WIN_CONDITION.square)) {
        showSuccessScreen();
        return true;
      }
      return false;
    }

    function hintForStep(i) {
      return STEP_HINTS[i] || "The plan continues…";
    }

    function wrongHint(i) {
      return WRONG_MOVE_HINTS[i % WRONG_MOVE_HINTS.length];
    }

    // -------------------------
    // NEW GAME
    // -------------------------
    var game, board, step;

    function newGame() {
      game = new Chess();
      step = 0;

      // Reset screens
      successScreen.style.display = "none";
      gameScreen.style.display = "block";

      // Create/Reset board
      if (board) {
        board.position("start");
      } else {
        board = Chessboard("board", {
          draggable: true,
          position: "start",
          pieceTheme: "./assets/vendor/chessboardjs-1.0.0/img/chesspieces/wikipedia/{piece}.png",

          onDragStart: function (source, piece) {
            // only allow white pieces
            if (piece.startsWith("b")) return false;

            // only allow white turn (prevents dragging during black auto-move)
            if (game.turn() !== "w") return false;

            // if solved screen is up, block
            if (successScreen.style.display === "block") return false;
          },

          onDrop: function (source, target) {
            if (source === target) return "snapback";

            const expected = SCRIPT[step]?.w;

            // If we've run out of script, stop enforcing
            if (!expected) {
              setStatus("The board is quiet. (No more scripted moves.)");
              return "snapback";
            }

            const uci = toUCI(source, target);

            // Enforce the exact move silently (no exact reveal)
            if (uci !== expected) {
              setStatus(wrongHint(step));
              return "snapback";
            }

            // Apply White move
            const wMove = makeMoveUCI(uci);
            if (wMove === null) {
              setStatus("Illegal move.");
              return "snapback";
            }

            board.position(game.fen());

            // If win triggered, stop
            if (checkWinCondition()) return;

            // Black scripted reply
            const bUci = SCRIPT[step].b;
            const bMove = makeMoveUCI(bUci);

            if (bMove === null) {
              setStatus("The opponent hesitates… (script error)");
              return;
            }

            step++;
            board.position(game.fen());

            // If win triggered, stop
            if (checkWinCondition()) return;

            // Give the next hint (vague)
            setStatus(hintForStep(step));
          }
        });
      }

      setStatus("White to move. " + hintForStep(0));
    }

    restartBtn.addEventListener("click", newGame);

    // Start
    newGame();
  </script>
</body>
</html>
